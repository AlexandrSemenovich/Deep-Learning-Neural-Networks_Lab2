# -*- coding: utf-8 -*-
"""lab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SrKj0QOYdCihH517K89d8FmqBpp9Ghq8

1) Подключение библиотек
"""

pip install numpy scipy scikit-image matplotlib

import os
from PIL import Image
import torch

"""3) Для удобного и полного форматирования ввода и вывода модели загрузите набор служебных методов."""

precision = 'fp32'
ssd_model = torch.hub.load('NVIDIA/DeepLearningExamples:torchhub', 'nvidia_ssd', model_math=precision)
utils = torch.hub.load('NVIDIA/DeepLearningExamples:torchhub', 'nvidia_ssd_processing_utils')

"""2) Загрузит модель SSD, предварительно обученную на наборе данных COCO из Torch Hub."""

ssd_model.to('cuda')
ssd_model.eval()
classes_to_labels = utils.get_coco_object_dictionary()

"""4) Определение модели IoU"""

def IoU(boxA, boxB):
    xA = max(boxA[0], boxB[0])
    yA = max(boxA[1], boxB[1])
    xB = min(boxA[2], boxB[2])
    yB = min(boxA[3], boxB[3])
    interArea = max(0, xB - xA) * max(0, yB - yA )
    boxAArea = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
    boxBArea = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])
    IoU = interArea / float(boxAArea + boxBArea - interArea)
    return IoU

def parse(anno,images):
    annotations = []
    for i in range(len(anno)):
        f = open(anno[i], 'r+')
        lines = [line.split(',') for line in f.readlines()]
        f.close()
        
        boxes = []
        for line in lines:
            box = [int(num) for num in line]
            boxes.append(box)
        im = Image.open(images[i])
        width, height = im.size
        im.close()
        left = (width-height)/2
        right = left + height
        
        j = 0;
        while j < len(boxes):
            if boxes[j][0]+boxes[j][2] <= left or boxes[j][0]>=right:
                del boxes[j]
                j = j-1
            elif boxes[j][0]<left:
                boxes[j][2] = boxes[j][0] + boxes[j][2] - left
                boxes[j][0] = 0
            elif boxes[j][0]+boxes[j][2]>right:
                boxes[j][2] = right-boxes[j][0]
                boxes[j][0] = boxes[j][0] - left
            else:
                boxes[j][0] = boxes[j][0] - left
            j = j+1    

        for box in boxes:
            del box[4]
            del box[5]
            del box[5]
            box[0] = box[0]/height
            box[2] = box[2]/height
            box[1] = box[1]/height
            box[3] = box[3]/height
        annotations.append(boxes)
    return annotations

def equalClasses(trueClass,predictedClass):
    if trueClass == predictedClass:
        return True
    elif trueClass == 'others':
        return True
    else:
        return False

"""Доступ и загрузка данных из Гугл Диска"""

from google.colab import drive
drive.mount('/content/gdrive',force_remount = True)
!cp /content/gdrive/'My Drive'/VisDrone2019-DET-train.zip .
!unzip VisDrone2019-DET-train.zip

imglist = os.listdir('VisDrone2019-DET-train/images')
annolist = os.listdir('VisDrone2019-DET-train/annotations')
annolist = [line.replace('.jpg','.txt') for line in imglist]
trueClasses = ['ignored regions', 'person', 'person', 'bicycle', 'car', 'car', 'truck', 'tricycle', 'awning-tricycle', 'bus', 'motorcycle', 'others']
